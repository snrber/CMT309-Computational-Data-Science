# -*- coding: utf-8 -*-
"""Q2.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1INfbk_cSZVaMLX5f1UPtsAscnr3vRG7k

Docstring
This file contains Question 2.
Q2.1:
The first matrix is initialised to improve readability. Then, the if statement
allows the first matrix column value to be compared with the second matrix row
value. This confirms whether the matrices can be multiplied. The for loop iterates
through each matrix and multiplies each one by the next according to standard
matrix multiplication, otherwise it prints an error message.

Q2.2:
This solution simply compares the shapes of each matrix to determine whether
the linear equations presented can be utilised.

Q2.3:
This solution uses the built in matrix multiplication functions in python
to perform the inverse operations according to the mathematics presented in
the performa. 
"""

#C22106798
#Q2.1

import numpy as np

def matrix_multiplication(*argv): 
  #Create initialising matrix
  res = argv[0] * 1

  #Checking if col in first matrix is same as row in second matrix to enable multiplication
  if np.size(argv[0][1]) == len(argv[1]):
    print("Matrix multiplication successful.")
    for x in range(len(argv) - 1):
      #Package row and col using zip() and perform multiplication
      res = [[sum(a*b for a, b in zip(res_row, res_col)) for res_col in zip(*argv[x + 1])] for res_row in res]
  else:
    print("Matrix dimension mismatch.")
    return None

  return res

#C22106798
#Q2.2

def linear_solver(A, b):
  #Create input arrays
  A = np.array(A)
  b = np.array(b)

  #Underdetermined case (column number bigger than row number)
  if np.shape(A)[0] < np.shape(A)[1]:
    print("Underdetermined system: infinitely many solutions.")
    return None

  #Overdetermined case (row number bigger than column number)
  elif np.shape(A)[0] > np.shape(A)[1]:
    print("Overdetermined system: no solutions.")
    return None

  #Unique solution case  
  else:
    inv_A = np.linalg.inv(A)
    res = np.array(matrix_multiplication(inv_A, b))
    print("Unique solution.")
    return res

#C22106798
#Q2.3

def LLS(A, b):
  
  #Using matrix functions and mathematics given in performa 
  transpose_A = A.T
  mpi = matrix_multiplication(np.linalg.inv(matrix_multiplication(transpose_A, A)), transpose_A)

  res = matrix_multiplication(mpi, b)

  return res
